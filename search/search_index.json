{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to twig","text":""},{"location":"#tree-based-workflows-for-integrative-genomics","title":"Tree-based Workflows for Integrative Genomics.","text":"<p>Twig is a command-line tool for phylogenomic and evolutionary analyses of orthogroups. It is designed in the fashion of unix utilities, with many small tools each intended to complete a simple task. It includes tools to trim and filter sequences and alignments to improve orthology; to filter, root, and modify gene trees in gene tree distributions; and wrappers for downstream analyses that take both CDS alignments and gene trees as inputs.</p>"},{"location":"#subcommands","title":"Subcommands","text":"<p>Use the <code>-h</code> flag to view the subcommands available in <code>twig</code>.</p> <pre><code>twig -h\n</code></pre> <pre><code>-----------------------------------------------------\n|  twig: tree-based workflows for integrative genomics |\n-----------------------------------------------------\n\noptions:\n  -h, --help         show this help message and exit\n  -v, --version      show program's version number and exit\n\nsubcommands:\n  --------------     -----------------------------------------------------\n    csubst           run csubst in wrapper\n    diamond-bl       search blastp hits of one protein fasta to another\n    diamond-pw       write .tsv blast hits for all pairs of fasta sequence files\n    format-fasta     format fasta to sort/filter/subset/relabel/modify sequences\n    format-gff       format gff to filter and relabel genes and scaffolds\n    genome-table     write table with chrom/scaff [names lengths ngenes]\n    filter-concat    filter loci and genes, concatenate down or right, convert .fa/.phy/.nex\n    macse-prep       prepare CDS for macse alignment (trim,filter,iso-collapse)\n    macse-align      run macse alignment (CDS/AA)\n    macse-refine     trim/filter/convert alignments\n    partition-cds    write a partition file for phylogenetic inference\n    tree-filter      filter and relabel a set of trees for downstream analyses\n    tree-rooter      Re-root gene trees by outgroup, species tree, and/or MAD\n    tree-skeleton    Force gene tree to match species tree topology\n</code></pre>"},{"location":"#calling-subcommands","title":"Calling subcommands","text":"<p>Each subcommand has its own help menu describing the utility, its parameters, and with examples. See the documentation for further examples.</p> <pre><code>twig tree-filter -h\n</code></pre> <pre><code>-------------------------------------------------------------------\n| tree-filter: Filter/Relabel a set of trees for downstream analyses\n-------------------------------------------------------------------\n| The order of [optional] operations is (1) parse names from delim\n| split tip labels; (2) subsample and/or relabel names by imap;\n| (3) exclude outlier edges; (4) collapse outgroups; (5) exclude\n| trees w/ &lt; min-tips; (6) exclude trees w/ &gt; min-copies in any name.\n| Note that if names are parsed by delim, then the imap should contain\n| the parsed names. The labels on output trees will be the same as in\n| the inputs unless --relabel-delim or --relabel-imap is used. But\n| parsing shorter names can be useful to match names to imap even\n| if keeping full names. Filtering stats are written to stderr, which\n| can be redirected to a log file with `2&gt; log.txt`.\n-------------------------------------------------------------------\n\noptions:\n  -h, --help                                     show this help message and exit\n  -i path, --input path                          newick or multi-newick trees file\n  -o path, --out path                            outfile name else printed to stdout\n  -d str, --delim str                            delimiter to split tip labels\n  -di int [int ...], --delim-idxs int [int ...]  index of delimited name items to keep\n  -dj str, --delim-join str                      join character on delimited name items\n  -I path, --imap path                           filepath listing names to keep, or assigning (name population)\n  -M path, --minmap path                         filepath listing (population mincov) for filters\n  -m int, --min-tips int                         min tips after pruning [4]\n  -c int, --max-copies int                       filter trees with &gt;c gene copies from a taxon [None]\n  -eo float, --edge-outlier-outgroup float       exclude 'outgroup' population edges if &gt;eo stdev from mean [10]\n  -ei float, --edge-outlier-ingroup float        exclude non 'outgroup' population edges if &gt;ei stdev from mean [5]\n  -rd, --relabel-delim                           relabel tips by their delim parsed names\n  -ri, --relabel-imap                            relabel tips to their imap mapped names\n  -S, --subsample                                subsample to include only tips in imap\n  -E, --exclude-outliers                         exclude tips with outlier edge lengths (&gt;ei or &gt;eo)\n  -R, --require-outgroups                        require at least one 'outgroup' sample\n  -C, --collapse-outgroups                       keep only the most distant 'outgroup' (assumes rooted trees)\n  -O path, --outgroups path                      path listing outgroups for -R (overrides IMAP group 'outgroup')\n  -l level, --log-level level                    stderr logging level (DEBUG, [INFO], WARNING, ERROR)\n\nExamples\n--------\n# relabel by split-select-join on tip names\n$ twig tree-filter -i NWK -d '-' -di 0 2 -dj '-rd' &gt; relabeled-trees.nwk\n\n# get only single-copy gene trees\n$ twig tree-filter -i NWK -c 1 &gt; single-copy-trees.nwk\n\n# get only trees w/ &gt;20 tips\n$ twig tree-filter -i NWK -m 20 &gt; min20-trees.nwk\n\n# exclude outlier edges\n$ twig tree-filter -i NWK --exclude -ei 4 &gt; cleaned-trees.nwk\n\nExamples using IMAP/MINMAP\n--------------------------\n# subsample to names in imap\n$ twig tree-filter -i NWK -I IMAP &gt; subsample-trees.nwk\n\n# subsample and relabel to pop names in imap\n$ twig tree-filter -i NWK -I IMAP -ri &gt; relabeled-trees.nwk\n\n# subsample, relabel, and keep only one outgroup (best to root before)\n$ twig tree-filter -i NWK -I IMAP -ri --collapse &gt; final-trees.nwk\n\nExample on a many trees in different paths\n-------------------------------------------\n$ parallel \"twig tree-filter -i {} ... &gt; {}.filtered\" ::: TREES/*.nwk\n\nExample IMAP                       Example MINMAP\n--------------------               ----------------\nsampleA     pop1                   pop1       1\nsampleB     pop1                   pop2       1\nsampleC     pop2                   outgroup   1\nsampleD     pop2\nsampleE     outgroup\nsampleF     outgroup\n</code></pre>"},{"location":"csubst/","title":"csubst","text":"<p>The <code>csubst</code> method by Fukushima and Pollack (2024) is used to detect evidence of adaptive molecular convergence given a CDS alignment and gene tree. It is implemented in a command-line tool [csubst GitHub link] that provides many options. The <code>twig csubst</code> tool is a simple wrapper around this tool to make it easier to run in alternative ways.</p>"},{"location":"csubst/#the-csubst-subcommand","title":"The csubst subcommand","text":"<pre><code>twig csubst -h\n</code></pre> <pre><code>usage: twig csubst -i MSA -t TREE -g FG [options]\n\n-------------------------------------------------------------------\n| csubst: A simple wrapper to run and extract results from csubst\n-------------------------------------------------------------------\n| ...\n-------------------------------------------------------------------\n\noptions:\n  -h, --help                      show this help message and exit\n  -a path, --alignment path       input CDS alignment\n  -t path, --tree path            input rooted tree file\n  -g path, --foreground path      foreground file\n  -o path, --outdir path          Out directory will be created at this path [./csubst]\n  -m int, --max-arity int         max combinatorial number of branches (K) [2]\n  -u int, --exhaustive-until int  perform exhaustive (non-heuristic) search up N branch combs [2]\n  -c str, --cutoff-stat str       Cutoff stats for searching higher-order branch combs\n                                  [OCNany2spe,2.0|omegaCany2spe,5.0]\n  -b, --foreground-table          foreground file is a table (fg_format=2)\n  -w, --fg-exclude-wg             sets 'yes' to exclude within-group comparisons\n  -s, --fg-stem-only              sets 'yes' to only stem comparisons\n  -e path, --env path             conda env name where 'csubst' in installed [csubst]\n  -j int, --threads int           number of threads\n  -v, --verbose                   print macse progress info to stderr\n  -f, --force                     overwrite existing result files in outdir\n  -l level, --log-level level     stderr logging level (DEBUG, [INFO], WARNING, ERROR)\n\nExamples\n--------\n$ twig csubst -a MSA -t NWK -g FG -o OUT/PRE\n</code></pre>"},{"location":"csubst/#running-twig-csubst","title":"Running twig csubst","text":"<pre><code>twig csubst -i MSA -t TREE -g FG ...\n</code></pre>"},{"location":"csubst/#why-use-twig-csubst","title":"Why use twig csubst","text":"<p>I find it to be convenient for the following two reasons:</p> <p>First, the current installation of csubst enforces some installation constraints, including on the version of numpy, and of the external iqtree tool. For this reason, it is good practice to create a unique conda environment just for installing csubst and iqtree2. You can specify that environment's name using the <code>-e</code> flag from <code>twig csubst</code> and it will run csubst from that environment without having to activate it. This way you can call and run this tool from your modern updated conda environment.</p> <p>Second, csubst generates output files in its current working directory. Which requires you to change directories a lot when running many files. A minor inconvenience. Instead you can set an output directory path with <code>-o</code> in <code>twig csubst</code>.</p> <p>That's it for now.</p>"},{"location":"installation/","title":"installation","text":""},{"location":"installation/#install-from-github","title":"Install from GitHub","text":"<p>While in development the best way to install twig is to install dependencies with conda and the install twig from GitHub using pip. <pre><code># install dependencies into a conda env\nconda install toytree diamond macse -c conda-forge -c bioconda\n\n# clone the repo\ngit clone git@github.com:eaton-lab/twig.git\n\n# install local source code in development mode\ncd twig/\npip install -e . --no-deps\n\n# test it\ntwig -h\n</code></pre></p>"},{"location":"installation/#conda-installation","title":"Conda installation","text":"<p>The preferred installation method is by using <code>conda</code> which will install the minimal required dependencies along with the <code>twig</code> tool.</p> <p>[THIS IS NOT YET AVAILABLE] <pre><code>conda install twig -c conda-forge\n</code></pre></p>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>The number of dependencies in twig is purposefully kept minimal to make installation simple and reliable. The core dependencies are listed below.</p> <pre><code>- toytree\n- pandas\n- numpy\n- scipy\n- loguru\n- diamond\n- ...\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional dependencies","text":"<p>There are also several optional tools that can be called from twig but which are not installed by default. This includes alternative software options for assessing homology among sequences and inferring  gene trees. If these options are selected during an ortholab analysis it will ask you to install the required dependency by providing a conda command. </p>"},{"location":"macse-align/","title":"macse-align","text":"<p>...</p>"},{"location":"macse-align/#the-macse-align-subcommand","title":"The macse-align subcommand","text":"<pre><code>-------------------------------------------------------------------\n| macse-align: run macse joint cds/aa alignment\n-------------------------------------------------------------------\n| Calls `macse -prog AlignSequences` and writes cds alignment\n| to {outpath}. This is an intermediate file. You should next\n| run `twig macse-refine` to trim/filter/convert to write final\n| cds and aa alignments.\n-------------------------------------------------------------------\n\noptions:\n  -h, --help                     show this help message and exit\n  -i path, --input path          input CDS (aligned or unaligned)\n  -o path, --outpath path        path to write aligned nt fasta\n  -m int, --max-refine-iter int  max refinement iterations during optimizing [default -1 = no limit]\n  -v, --verbose                  print macse progress info to stderr\n  -f, --force                    overwrite existing result files in outdir\n  -l level, --log-level level    stderr logging level (DEBUG, [INFO], WARNING, ERROR)\n</code></pre>"},{"location":"macse-align/#running-twig-macse-align","title":"Running twig macse-align","text":"<pre><code>Examples\n--------\n$ twig macse-align -i CDS -o /OUT/CDS.msa\n</code></pre>"},{"location":"macse-align/#parallelization","title":"Parallelization...","text":"<pre><code># run parallel jobs on many cds files\n$ parallel -j 10 \"twig macse-align -i {} ...\" ::: CDS/*.nt.fa\n</code></pre>"},{"location":"macse-align/#full-pipeline","title":"full pipeline","text":"<pre><code># full pipeline\n$ twig macse-prep -i CDS -o TRIM     # {TRIM}\n$ twig macse-align -i TRIM -o MSA    # {MSA}\n$ twig macse-refine -i MSA -o MSA    # {MSA}.nt.fa, {MSA}.aa.fa\n</code></pre>"},{"location":"macse-prep/","title":"macse-prep","text":"<p>The <code>macse-prep</code> command is a wrapper tool intended to apply and extend features of the method <code>trimNonHomologousFragments</code> in <code>macse</code>. This applies a kmer approach to compare substrings between sequences to identify and trim fragments or sequences that do not pass minimum thresholds for homology. This helps to prevent the inclusion of very low homology sequences in downstream steps where they can greatly affect alignments. Low homology sequences can end up in orthogroups when using very low thresholds for homology identification.</p> <p>This step measures homology separately across full sequences (<code>-hf</code>) and the non-edge/internal parts of sequences (<code>-hi</code>) by counting exact matches in subsequences (<code>-mm</code> length). Internal or external sequence fragments that fall below this threshold, and are longer than some minimum length setting (<code>-ti</code> or <code>-te</code>) can be trimmed from sequences. Homology is assessed pairwise between all samples and each fragment must share homology above this min threshold with a set minimum number of other samples (<code>-mc</code>). After non-homologous fragments are removed, if a sample does not exceed the homology thresholds with others samples it is discarded.</p> <p>We implement a number of additional filtering steps in addition to macse. Trimmed sequences that fall below a minimum length (<code>-ml</code>) are discarded. Isoforms can also be excluded at this step by entering an isoform regular expression that will group sequences of the same sample and gene, but different isoform, by header names. The default looks for Trinity-type naming conventions with <code>_i0</code>, <code>_i1</code>, etc. at the end of names. You can likely build a similar expression for your samples using help from a chatbot. This will select only the isoform that has highest homology with other samples to keep, and discard extra isoforms. This step can be toggled off with the <code>-xi</code> option.</p>"},{"location":"macse-prep/#the-macse-prep-subcommand","title":"The macse-prep subcommand","text":"<pre><code>twig macse-prep -h\n</code></pre> <pre><code>-------------------------------------------------------------------\n| macse-prep: prepare CDS for alignment (trim, filter, iso-collapse)\n-------------------------------------------------------------------\n| Macse ...\n| This implements `macse -prog trimNonHomologousFragments` and\n| additional steps to ...\n-------------------------------------------------------------------\n\noptions:\n  -h, --help                                        show this help message and exit\n  -i path, --input path                             input CDS (aligned or unaligned)\n  -o path, --outpath path                           path to write nt fasta result\n  -e [str ...], --exclude [str ...]                 optional names or glob to exclude one or more sequences\n  -s [str ...], --subsample [str ...]               optional names or glob to include only a subset sequences\n  -ml int, --min-length int                         min nt sequence length after trimming [0]\n  -mc int, --min-count int                          min num sequences that must pass filtering to write output [0]\n  -hf float, --min-homology-full float              min homology required w/ &gt;=mc others across full sequence [0.1]\n  -hi float, --min-homology-internal float          min homology required w/ &gt;=mc others in the internal sequence [0.5]\n  -hc int, --min-homology-coverage int              min samples a seq must share homology with at &gt;= mh and mi [3]\n  -ti int, --min-trim-length-homology-internal int  trim fragments w/ len &lt;ti and homology &lt;mi w/ &lt;mc sequences [50]\n  -te int, --min-trim-length-homology-external int  trim fragments w/ len &lt;tx and homology &lt;mh w/ &lt;mc sequences [50]\n  -mm int, --mem-length int                         homology is the prop of aa Maximum Exact Matches of this length [6]\n  -is str, --isoform-regex str                      regex used to group isoform sequences ['^([^|]+)\\|.*?__(.+?)_i\\d+']\n  -xi, --skip-isoform-collapse                      skip isoform collapse step\n  -v, --verbose                                     print macse progress info to stderr\n  -f, --force                                       overwrite existing result files in outdir\n  -k, --keep                                        keep tmp files (for debugging)\n  -l level, --log-level level                       stderr logging level (DEBUG, [INFO], WARNING, ERROR)\n</code></pre>"},{"location":"macse-prep/#running-twig-macse-prep","title":"Running twig macse-prep","text":"<p>Some commonly used example parameter settings: <pre><code>$ twig macse-prep -i CDS -o OUT.nt.fa\n$ twig macse-prep -i CDS -hf 0.1 -hi 0.5 -ti 50 -te 50 -hc 15\n$ twig macse-prep -i CDS -hf 0.3 -hi 0.8 -ti 25 -te 25 -hc 15\n$ twig macse-prep -i CDS -hf 0.5 -hc 10 -k -ml 200 -e '^sppA.*'\n$ twig macse-prep -i CDS -s '^sppA.*'\n</code></pre></p>"},{"location":"macse-prep/#options","title":"Options","text":""},{"location":"macse-prep/#-input-and-outpath","title":"--input and --outpath","text":"<p>...</p>"},{"location":"macse-prep/#-exclude-and-subsample","title":"--exclude and --subsample","text":"<p>A list of sample names or glob pattern can be used to select samples by name that should be excluded from the analysis using <code>--exclude</code>, and/or select the subset that you want to be included using <code>--subsample</code>. This is convenient for testing and/or discarding samples.</p>"},{"location":"macse-prep/#-min-length","title":"--min-length","text":"<p>...</p>"},{"location":"macse-prep/#-min-count","title":"--min-count","text":"<p>...</p>"},{"location":"macse-prep/#_1","title":"macse-prep","text":""},{"location":"macse-prep/#extras","title":"Extras","text":""},{"location":"macse-prep/#why-use-twig-macse-prep","title":"Why use twig macse-prep","text":"<p>It provides a convenient interface to <code>macse trimNonHomologousFragments</code> paired with a number of additional sequence filtering options to include/exclude samples, filter by length, filter by number of passing sequences, and select/collapse isoforms by highest homology/length.</p>"},{"location":"macse-prep/#parallelization","title":"Parallelization","text":"<p>There are two easy ways to parallelize macse-prep over many samples. The first is to use gnu parallel (easy to install on a linux or mac) and iterate over a set of fasta files in a directory, and specifying their out path.</p> <pre><code># run parallel jobs on many cds files\n$ parallel -j 10 \"twig macse-prep -i {} ...\"  ::: CDS/*.fa\n</code></pre> <p>The other way that might be more commonly employed on an HPC cluster is to write a batch script ... <pre><code>...\n</code></pre></p>"},{"location":"macse-prep/#full-pipeline","title":"full pipeline","text":"<p>This step is part of a 3-step pipeline for jointly aligning CDS and AA sequences: <pre><code>$ twig macse-prep -i CDS -o TRIM     # {TRIM}\n$ twig macse-align -i TRIM -o MSA    # {MSA}\n$ twig macse-refine -i MSA -o MSA    # {MSA}.nt.fa, {MSA}.aa.fa\n</code></pre></p>"},{"location":"macse-refine/","title":"macse-refine","text":"<p>After sequences have been aligned the <code>macse-refine</code> step can be used to trim edges, mask frameshift or stop codons, perform quality filtering, and write the final CDS to proteins alignments to file. Edge trimming, masking, and writing is performed using a wrapper around <code>macse ...</code>. We provide an additional filter to examine overlap among sequences in an alignment and enforce a minimum overlap between samples. This is very important for preventing terraces during phylogenetic inference, where some samples share no phylogenetic information. This can arise in orthogroups often when they were clustered together based on different shared motifs. Sequences that do not overlap with at least N other sequences by X amount of nucleotides are iteratively removed until all meet the minimum requirements, or the alignment fails quality check.</p>"},{"location":"macse-refine/#the-twig-macse-refine-subcommand","title":"The twig macse-refine subcommand","text":"<pre><code>twig macse-refine -h\n</code></pre> <pre><code>-------------------------------------------------------------------\n| macse-refine: CDS/AA jointly and filter low homology seqs\n-------------------------------------------------------------------\n| Macse codon-aware alignment of CDS and AA sequences. This method\n| takes an alignment from `twig macse-refine` and can subsample/\n| filter to remove selected samples, or those with too little\n| overlap with others (-mo), then refine the alignment, and write\n| final alignments with optional conversion of frameshift and stop\n| codons.\n-------------------------------------------------------------------\n\noptions:\n  -h, --help                                     show this help message and exit\n  -i path, --input path                          input aligned CDS\n  -o path, --outprefix path                      out prefix; creates {prefix}.nt.fa and {prefix}.aa.fa\n  -e [str ...], --exclude [str ...]              optional names or glob to exclude one or more sequences\n  -s [str ...], --subsample [str ...]            optional names or glob to include only a subset sequences\n  -t path, --tree path                           optional newick file to subsample genes present in tree\n  -mo int, --min-overlap int                     min sites shared by each pair of samples, else iter prune lowest [0]\n  -ms int, --min-samples int                     min samples after filtering else error [0]\n  -ac float, --aln-trim-ends-min-coverage float  trim alignment edges to where a min percent of samples have data [0.4]\n  -as int, --aln-trim-window-size int            trim alignment edges using a sliding 'half_window_size' [5]\n  -if str, --codon-int-fs str                    codon to sub for internal frame shift [NNN]\n  -ef str, --codon-ext-fs str                    codon to sub for external frame shift [NNN]\n  -fs str, --codon-final-stop str                codon to sub for final stop [NNN]\n  -is str, --codon-int-stop str                  codon to sub for internal stop [NNN]\n  -r, --refine-alignment                         refine alignment\n  -R, --refine-alignment-if                      refine alignment only if &gt;=1 sequences are filtered out\n  -ri int, --max-iter-refine-alignment int       max iterations in refine alignment [-1]\n  -v, --verbose                                  print macse progress info to stderr\n  -f, --force                                    overwrite existing result files in outdir\n  -k, --keep                                     keep tmp files (for debugging)\n  -l level, --log-level level                    stderr logging level (DEBUG, [INFO], WARNING, ERROR)\n</code></pre>"},{"location":"macse-refine/#running-twig-macse-refine","title":"Running twig macse-refine","text":"<pre><code>Examples\n--------\n$ twig macse-refine -i CDS -o PATH/PRE -ac 0.5\n$ twig macse-refine -i CDS -o PATH/PRE -t NWK -R\n$ twig macse-refine -i CDS -fs XXX -is XXX\n</code></pre>"},{"location":"macse-refine/#options","title":"Options","text":"<p>...</p>"},{"location":"macse-refine/#parallelization","title":"Parallelization","text":"<pre><code># run parallel jobs on many cds files\n$ parallel -j 10 \"twig macse-refine -i {} ...\"  ::: CDS/*.msa.nt.fa\n</code></pre>"},{"location":"macse-refine/#full-pipeline","title":"Full pipeline","text":"<pre><code># full pipeline\n$ twig macse-prep -i CDS -o TRIM        # {TRIM}\n$ twig macse-align -i TRIM -o ALN       # {ALN}\n$ twig macse-refine -i ALN -o MSA       # {MSA}.nt.fa, {MSA}.aa.fa\n</code></pre>"},{"location":"quick-guide/","title":"quick guide","text":""},{"location":"quick-guide/#example-dataset","title":"Example dataset","text":"<p>...</p>"},{"location":"quick-guide/#the-fastest-guide","title":"The fastest guide","text":"<p>You can perform an ortholab analysis to assemble and analyze orthogroups using the all-in-one analysis command <code>orthogroup run</code>. This takes a large number of options that can be used to specify the run. It will identify orthology among sequences to group them into orthogroups; align and trim  orthogroup sequences; infer gene trees; infer a species tree; root gene  trees and species trees; and report a number of evolutionary analyses of orthogroups.</p> <pre><code># run the full analysis in one or few commands\northolab run data/*.faa \n</code></pre>"},{"location":"quick-guide/#sequence-orthology","title":"Sequence orthology","text":"<p>A primary goal of ortholab is to identify homology among sequences both within and between biological samples to enable evolutionary analyses.</p>"},{"location":"quick-guide/#fetch-transcriptome-datasets","title":"Fetch transcriptome datasets","text":"<p>See the data-guide (link) for tips on assembling transcriptome datasets for use in ortholab, and/or accessing publicly accessible datasets from online repositories.</p> <p><pre><code># download an example dataset\northolab seqs download --database phytozome --accession 23456 --all\n</code></pre> <pre><code># filetree of example dataset (collapsible)\n...\n</code></pre></p>"},{"location":"quick-guide/#preprocess-data","title":"Preprocess data","text":"<p>Many datasets will vary in ... One major aspect is in the sequence labels store in the protein or cds fasta files (also referred to as fasta headers).</p> <pre><code># create a map ..\northolab seqs create-relabel-map data/*/*.proteins.faa.gz &gt; map_proteins.tsv\n\n# optionally also crate one for the CDS\northolab seqs create-relabel-map data/*/*.cds.fna.gz &gt; map_cds.tsv\n</code></pre> <p>If you create both it is important that the label columns match between the two. <pre><code># show map TSV collapsible\n</code></pre></p>"},{"location":"quick-guide/#homology-scores","title":"Homology scores","text":"<p>There are many options that can be implemented in this tool to modify which  program is used to measure homology, and what the minimum cutoff will be. See the tools tutorial page (link). This will use the map file to relabel sequences as they are passed into the blast database. <pre><code>ortholab seqs homology-score \\\n    data/*/*.proteins.faa.gz \\\n    --map map.tsv \\\n    --tool diamond-blast \\\n    --max-evalue 0.001 \\\n    --outdir blastdir/ \\\n    --use-labels\n</code></pre></p> <p>The blast table format can be modified with options to the tool above, but we restrict it such that the first X columns will always contain the  same information, and additional requested features are appended as the final columns.</p> <p>From looking at this table you can see that we have scored hits between sequences sometimes with very low sequence similarity scores. This is sometimes desirable. In the cases where we do not want to allow such  deep homology, don't worry, we can filter the hits more strictly in the next step. However, if you modify run parameters of this step, such as changing the max-evalue or ... , it can have the effect of making the homology search run faster. <pre><code># show blast table collapsible\n</code></pre></p>"},{"location":"quick-guide/#homology-filtering","title":"Homology filtering","text":"<pre><code># filter homology hits to write a graph\northolab seqs homology-graph \\\n    blastdir/*.tsv \\\n    --min-identity 0.5 \\\n    --max-... 5 \\\n    --min-... 0.1 \\\n    ... \\\n    --length-normalize \\\n    --require-rbbh \\\n    --outdir blastdir \\\n    --prefix test\n</code></pre> <p>The graph is represented by pairs of sequence labels and a weight value. This graph file can be visualized in a tool like ...  Following the approach used by OrthoMCL and Orthofinder, we will split this graph into smaller orthogroups using a Markov Clustering method  in <code>mcl</code>. This takes an inflation parameter <code>-i</code> which ...</p> <pre><code># show blast table collapsible\n</code></pre>"},{"location":"quick-guide/#orthogroup-identification","title":"Orthogroup identification","text":"<p>Next we write each group of orthologous sequences (orthogroup) to a file. This tool will take an orthogroup set split from the graph in the previous step and write a orthogroup</p> <pre><code># filter homology hits to write a graph\northolab seqs homology-split \\\n    --graph blastdir/homology-graph.tsv \\\n    --databases blastdir/blast*.tsv \\\n    --map map.tsv \\\n    --format [json,tsv] \\\n    &gt; blastdir/orthogroups-i-1.5.tsv\n</code></pre>"},{"location":"quick-guide/#orthogroup-refinement","title":"Orthogroup refinement","text":"<p>In many other software tools you now simply proceed to use your orthogroup sequences in downstream analyses and assume that homology was accurately assessed. However, in ortholab we provide a number of additional tools that allow you to incorporate information you can learn from downstream analyses to feedback into the orthology assessment in order to refine your orthogroup assignments. This can be an iterative process. </p> <p>The two primary sources of additional information include gene tree relationships and synteny.  <pre><code>TODO\n</code></pre></p>"},{"location":"quick-guide/#orthogroup-sequence-trimming-alignment","title":"Orthogroup sequence trimming &amp; alignment","text":"<p>Before running evolutionary analysis of orthogroup sequences we should filter and align  them. Filters can be used to skip files that do not have taxa of interest. </p> <pre><code># filter homology hits to write a graph\northolab seqs orthogroup-align \\\n    --orthogroups/*.faa \\\n    --map map.tsv \\\n    --cds ... \\\n    --align-tool macse2 \\\n    --trim-tool ... \\\n    # require taxon A,B,C (use if --map then use mapped names)\n    --sample-require A B \\ \n    # exlude sequence with too many variant sites, indels?\n    --sequence-filter ... \\  # \n</code></pre>"},{"location":"quick-guide/#tree-analyses","title":"Tree analyses","text":"<p>Now that we have assembled sequences into orthogroups we can proceed to infer the evolutionary relationships among sequences. </p> <pre><code>ortholab trees infer-gene-trees \\\n    --model GTR+G+F4 \\\n    --bootstraps 100 \\\n    --max-copy-number 10 \\\n    --max-size 1000 \\\n    --cores 40 \\\n    --threads 10 \\\n    --outdir gene-trees/\n</code></pre> <pre><code>\n</code></pre> <p>```bash ortholab trees draw gene-trees/OG1.nwk </p>"},{"location":"quick-guide/#evolutionary-analyses","title":"Evolutionary analyses","text":"<p>...</p>"},{"location":"quick-guide/#utilities","title":"Utilities","text":"<p>...</p>"},{"location":"tree-filter/","title":"tree-filter","text":"<p>The <code>twig tree-filter</code> tool can be used to filter one tree, or a set of trees, based on a set of parameters. You can collapse low-support branches, subselect samples, rename samples; filter trees by min number of tips or min number of resolved edges; drop edges that have outlier edges lengths; collapse outgroup clades; exclude trees with paralogs; and more.</p>"},{"location":"tree-filter/#the-tree-filter-command","title":"The tree-filter command","text":"<pre><code>twig tree-filter -h\n</code></pre> <pre><code>-------------------------------------------------------------------\n| tree-filter: Filter/Relabel a set of trees for downstream analyses\n-------------------------------------------------------------------\n| The order of [optional] operations is (1) parse names from delim\n| split tip labels; (2) subsample and/or relabel names by imap;\n| (3) exclude outlier edges; (4) collapse outgroups; (5) exclude\n| trees w/ &lt; min-tips; (6) exclude trees w/ &gt; min-copies in any name.\n| Note that if names are parsed by delim, then the imap should contain\n| the parsed names. The labels on output trees will be the same as in\n| the inputs unless --relabel-delim or --relabel-imap is used. But\n| parsing shorter names can be useful to match names to imap even\n| if keeping full names. Filtering stats are written to stderr, which\n| can be redirected to a log file with `2&gt; log.txt`.\n-------------------------------------------------------------------\n\noptions:\n  -h, --help                                     show this help message and exit\n  -i path, --input path                          newick or multi-newick trees file\n  -o path, --out path                            outfile name else printed to stdout\n  -d str, --delim str                            delimiter to split tip labels\n  -di int [int ...], --delim-idxs int [int ...]  index of delimited name items to keep\n  -dj str, --delim-join str                      join character on delimited name items\n  -I path, --imap path                           filepath listing names to keep, or assigning (name population)\n  -M path, --minmap path                         filepath listing (population mincov) for filters\n  -m int, --min-tips int                         min tips after pruning [4]\n  -c int, --max-copies int                       filter trees with &gt;c gene copies from a taxon [None]\n  -eo float, --edge-outlier-outgroup float       exclude 'outgroup' population edges if &gt;eo stdev from mean [10]\n  -ei float, --edge-outlier-ingroup float        exclude non 'outgroup' population edges if &gt;ei stdev from mean [5]\n  -rd, --relabel-delim                           relabel tips by their delim parsed names\n  -ri, --relabel-imap                            relabel tips to their imap mapped names\n  -S, --subsample                                subsample to include only tips in imap\n  -E, --exclude-outliers                         exclude tips with outlier edge lengths (&gt;ei or &gt;eo)\n  -R, --require-outgroups                        require at least one 'outgroup' sample\n  -C, --collapse-outgroups                       keep only the most distant 'outgroup' (assumes rooted trees)\n  -O path, --outgroups path                      path listing outgroups for -R (overrides IMAP group 'outgroup')\n  -l level, --log-level level                    stderr logging level (DEBUG, [INFO], WARNING, ERROR)\n</code></pre>"},{"location":"tree-filter/#io-input-and-output","title":"I/O: --input and --output","text":"<p>The input to tree-filter is a text file containing one or more newick trees, and the outout is written either to a specified file path <code>--out</code> or to STDOUT. If multiple tree are present in the input file the output will write the trees that pass filtering in the same order. A stats summary of how many trees passed filtering and the reasons that each failed is written to STDERR. A useful workflow to capture the output on STDOUT and the stats log on STDERR is to run: <pre><code>twig tree-filter -i NWK 1&gt; OUT 2&gt; LOG\n</code></pre></p>"},{"location":"tree-filter/#renaming-tips","title":"Renaming tips","text":"<p>There are many options for relabeling tips using tree-filter, which can be used not only to write trees with new tip labels, but also to perform operations/filters on trees based on both taxon and gene names that can be parsed from labels. ... <pre><code>...\n</code></pre></p>"},{"location":"tree-filter/#subselect-tips","title":"Subselect tips","text":"<p>...</p>"},{"location":"tree-filter/#filtering-edges-by-length","title":"Filtering edges by length","text":"<p>...</p>"},{"location":"tree-filter/#filtering-edges-by-support","title":"Filtering edges by support","text":"<p>...</p>"},{"location":"tree-filter/#filtering-trees-by-ntips","title":"Filtering trees by ntips","text":"<p>...</p>"},{"location":"tree-filter/#filtering-trees-by-nedges","title":"Filtering trees by nedges","text":""},{"location":"tree-filter/#filtering-trees-by-duplicates-paralogs","title":"Filtering trees by duplicates (paralogs)","text":""},{"location":"tree-filter/#collapsing-outgroup-clades","title":"Collapsing outgroup clades","text":""},{"location":"tree-filter/#requiring-outgroups","title":"Requiring outgroups","text":"<p>The -R and -O flags are used together to filter trees by the requirement that one or more outgroups is present. Outgroup names are specified in a file selected by -O. If the names are taxon names (e.g., SppA), then you can use -d, -di, and dj to parse tip names to sample only the relevant taxon name part, in the case that tip labels are longer gene names (e.g., SppA-geneX-isoformY).</p> <pre><code>twig tree-filter -i NWK -d \"-\" -di 1 -O OUTGROUPS.txt -R 1&gt;NWK2 2&gt;LOG\n</code></pre> <p>A summary of the filtering is printed to stderr. <pre><code>{tree-filtered: 0, ...}\n</code></pre> And the filtered tree or trees is printed to stdout. If no trees passed filtering then nothing will be printed to stdout. <pre><code>((...))\n</code></pre></p>"}]}